\documentclass[10pt]{article}
%-------------------------------------------------------------
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathptmx}
\usepackage{moreverb}
\usepackage[all]{xy}
\usepackage{rotating}
%--------------------------------------------------------------
\newcommand{\la}[1]{\label{#1}}
\newcommand{\re}[1]{(\ref{#1})}
\newcommand{\bmx}{\begin{bmatrix}}
\newcommand{\emx}{\end{bmatrix}}
\newcommand{\bsm}{\left[\begin{smallmatrix}}
\newcommand{\esm}{\end{smallmatrix}\right]}
\newcommand{\R}{\ensuremath{\mathbb{R}}} % real numbers
\newcommand{\N}{\ensuremath{\mathbb{N}}} % natural numbers
\newcommand{\C}{\ensuremath{\mathbb{C}}} % complex numbers
\newcommand{\Z}{\ensuremath{\mathbb{Z}}} % integer numbers
% --- Basic linear algebra definitions
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\tr}{\operatorname{trace}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\blkdiag}{\operatorname{blk\,diag}}
\newcommand{\abs}[1]{|#1|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\mtov}{\operatorname{vec}}
\newcommand{\bo}{\text{\bf 1}} % vector of ones
\newcommand{\F}{\text{\rm F}}  % Frobenius norm
\newcommand{\col}{\operatorname{col}} % column vector
\newcommand{\coldim}{\operatorname{col\,dim}}
\newcommand{\rowdim}{\operatorname{row\,dim}}
\newcommand{\image}{\operatorname{image}}
\newcommand{\colspan}{\operatorname{col\,span}} 
\newcommand{\rowspan}{\operatorname{row\,span}}
\newcommand{\degree}{\operatorname{degree}}
\newcommand{\clo}{{\operatorname{closure}}}
\newcommand{\dist}{\operatorname{dist}}
\newcommand{\B}{\mathcal{B}}    % model
\newcommand{\calL}{\mathcal{L}} % LTI model class
\newcommand{\io}{\text{\rm i/o}}  
\newcommand{\tin}{\text{\rm i}}   % input
\newcommand{\tout}{\text{\rm o}}  % ouput
\newcommand{\ttm}{{\tt m}} % # inputs
\newcommand{\ttp}{{\tt p}} % # outputs
\newcommand{\ttl}{{\tt l}} % # latent variables
\newcommand{\ttd}{{\tt d}} % # latent variables
\newcommand{\ls}{\text{\rm ls}}
\newcommand{\wls}{\text{\rm wls}}
\newcommand{\als}{\text{\rm als}}
\newcommand{\tls}{\text{\rm tls}}
\newcommand{\gtls}{\text{\rm gtls}}
\newcommand{\wtls}{\text{\rm wtls}}
\newcommand{\fwtls}{\text{\rm fwtls}}
\newcommand{\rml}{\text{\rm l}}   % left, ch2
\newcommand{\rmr}{\text{\rm r}}   % right, ch2
\newcommand{\matlab}{{\sc Matlab}}
%--------------------------------------------------------------
\theoremstyle{remark}
\newtheorem{note}{Note} 
%--------------------------------------------------------------
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}
\newcommand{\cf}{{\em cf.}}
\newcommand{\etc}{{\em etc}}
\newcommand{\etal}{{\em et~al.}}
%--------------------------------------------------------------
\renewcommand{\baselinestretch}{1}
\topmargin=-2.2cm  \oddsidemargin=-1cm \evensidemargin=-1cm 
\textheight=25.8cm   \textwidth=18cm
%--------------------------------------------------------------
\newcommand{\funinput}[1]{\medskip{{\small\tt\underline{#1}}}\verbatiminput{#1}}
\newcommand{\important}[1]{\begin{center}\framebox[.95\textwidth]{\begin{minipage}{.9\textwidth}\smallskip#1\smallskip\end{minipage}}\end{center}}
%--------------------------------------------------------------

\begin{document}

\title{A \matlab\ toolbox for weighted total least squares approximation}
\author{Ivan Markovsky and Sabine Van Huffel}
\maketitle
\date

\begin{abstract}
The toolbox solves a variety of approximate modeling problems for linear static models. The model can be parameterized in kernel, image, or input/output form and the approximation criterion, called misfit, is a weighted norm between the given data and data that is consistent with the model. There are three main classes of functions in the toolbox: transformation functions, misfit computation functions, and approximation functions. The approximation functions derive an approximate model from data, the misfit computation functions are used for validation and comparison of models, and the transformation functions are used for deriving one model representation from another.
\end{abstract}

\section{Introduction}\la{s1}

\subsection*{Purpose}

The weighted total least squares toolbox contains \matlab\ functions (m-files) for data approximation by linear static models. The data is a collection of~$N$, $\ttd$-dimensional real vectors $d_1,\ldots,d_N\in\R^\ttd$, gathered in a matrix $D:=\bmx d_1 & \cdots & d_N \emx\in\R^{\ttd\times N}$, and a linear static model~$\B$ for~$D$ is a subspace of~$\R^\ttd$. The natural number $\ttm:=\dim(\B)$ is a measure of the model complexity and $\calL^\ttd_{\ttm,0}$ denotes the set of all linear static models with $\ttd$ variables of dimension {\em at most\/}~$\ttm$.

A linear static model $\B\in\calL^\ttd_{\ttm,0}$ can be represented as a kernel or image of a matrix or in what is called an input/output form, see Table~\ref{t1}.
\begin{table}[htb!]
\centering
\caption{Representations of linear static models.} \la{t1}
\vskip.15cm
\begin{tabular}{|l|cl|l|}
\hline
Representation & \multicolumn{2}{|c|}{Parameter} & Model corresponding to that representation and parameter \\
\hline
Kernel         & $R\in\R^{g\times\ttd}$    &nonunique & $\B = \ker(R)   = \{\, d\in\R^\ttd \ | \ Rd = 0 \,\}$ \\
Image          & $P\in\R^{\ttd\times\ttl}$ &nonunique & $\B = \image(P) = \{\, d\in\R^\ttd \ | \ d = Pl, \ l\in\R^\ttl \,\}$ \\
Input/output   & $X\in\R^{\ttm\times\ttp}$ &unique     & $\B = \B_\io(X) = \{\, d = \col(d_\tin,d_\tout)\in\R^\ttd \ | \ d_\tout = X^\top d_\tin , \ d_\tin\in\R^\ttm \,\}$ \\
\hline
\end{tabular}
\end{table}

A representation of the model yields a parameterization. The model is described by equations that depend on parameter and to a given parameter corresponds a unique model. For a given model and a chosen representation, however, the corresponding parameter might not be unique. The nonuniqueness of the kernel and image representations are due to nonminimality of the representation ($R$ being not full row rank and $P$ being not full column rank) and due to freedom in the choice and of basis ($\ker(R) = \ker(UR)$ and $\image(P) = \image(PV)$ for any nonsingular matrices $U\in\R^{g\times g}$ and $V\in\R^{\ttl\times\ttl}$). The nonuniqueness in an input/output representation is due to the various possible partitionings of the variables into inputs (free variables) and outputs (dependent variables). The representation $\B_\io(X)$, however, has a fixed input/output partition, so that the parameter~$X$ is unique.

We use the short hand notation
$$
D = \bmx d_1 & \cdots & d_N\emx \in \B \quad :\iff \quad d_i\in\B, \quad\text{for } i=1,\ldots,N.
$$
If $D\in\B$, the model~$\B$ fits the data~$D$ exactly. If $D\not\in\B$, the model~$\B$ fit the data~$D$ only approximately. For optimal approximate modeling a distance function, called {\em misfit\/}, is defined as follows:
\begin{equation}
M_\wtls\big(\bmx d_1 & \cdots & d_N\emx,\B\big) := \min_{\hat d_1,\ldots,\hat d_N\in\B} \  \sqrt{ \sum_{i=1}^{N} (d_i - \hat d_i)^{\top} W_i (d_i - \hat d_i)} , \la{Mwtls}\tag{Mwtls}
\end{equation}
where $W_1,\ldots,W_N$ are given positive definite matrices. The weighted total least squares (WTLS) misfit $M_\wtls(D,\B)$ between the data~$D$ and a model $\B\in\calL_{\ttm,0}^\ttd$ is a measure of how much the model fails to fit the data exactly. The considered approximate modeling problem is:
\important{Given the data matrix $D = \bmx d_1 & \cdots & d_N\emx\in\R^{\ttd\times N}$, a complexity bound~$\ttm$, and weight matrices  $W_1,\ldots,W_N$, find an approximate model
\begin{equation}
\hat\B_{\wtls} := \arg\min_{\hat\B\in\calL_{\ttm,0}^\ttd} M_\wtls(D,\hat\B).  \la{wtls}\tag{WTLS}
\end{equation}\vskip-.25cm}
The special cases listed in Table~\ref{t2} allow for special solution methods and are treated separately.
\begin{table}[htb!]
\centering
\caption{Special cases of the weighted total least squares problem~\re{wtls}.} \la{t2}
\vskip.15cm
\begin{tabular}{|ll|l|l|}
\hline
Special case & & Name & Acronym \\
\hline
$W_i = \sigma^2I$        & $\sigma\in\R_+$                & total least squares & TLS \\
$W_i = \diag(w)$         & $w\in\R_+^\ttd$                & element-wise generalized total least squares & EWGTLS \\
$W_i = W$                & $W>0$                          & generalized total least squares & GTLS \\
$M_{\wtls} = M_{\gtls2}$ & $W_\rml,W_\rmr>0$ diagonal     & EWGTLS with two side weighting & EWGTLS2 \\
$M_{\wtls} = M_{\gtls2}$ & $W_\rml,W_\rmr>0$              & GTLS with two side weighting & GTLS2 \\
$W_i = \diag(w_i)$       & $w_i\in\R_+^\ttd$              & element-wise weighted total least squares & EWTLS \\
\hline
\end{tabular}
\begin{equation*}
M_{\gtls2}(D,\B) := \min_{\hat D\in\B}\norm{\sqrt{W_\rml}(D-\hat D)\sqrt{W_\rmr}}_\F %\la{gtls2}\tag{GTLS2}
\end{equation*}
\end{table}

\begin{note}
The following weighted total least squares problem, called fully weighted total least square (FWTLS) problem
$$
\hat\B_{\fwtls} := \arg\min_{\hat\B\in\calL_{\ttm,0}^\ttd} \min_{\hat D\in\hat\B} \mtov^\top(D-\hat D) W \mtov(D-\hat D),\quad \text{where}\quad W\in\R^{\ttd N\times\ttd N}
$$
is also considered. It includes~\re{wtls} as a special case with $W=\blkdiag(W_1,\ldots,W_N)$. The FWTLS problem, however, does not allow for efficient computational methods and its solution is prohibitive already for small sample size problems (say $\ttd=10$ and $N=100$). For this reason the FWTLS problem is not the central problem of interest and is included only for completeness. 
\end{note}

\subsection*{Algorithms}

The special cases listed in Table~\ref{t2} have increased generality from top to bottom. The more general the problem is, however, the more computationally expensive its solution is. The TLS and GTLS problems allow for analytic solutions in terms of the singular value decomposition (SVD). The more general EWTLS, WTLS, and FWTLS problems (currently) have no such analytic solutions and use less robust iterative solution methods. 

The SVD method is computationally faster than the alternative iterative optimization methods and theoretically characterizes all globally optimal solutions. In contrast, the iterative optimization methods (used in the package) compute one locally optimal solution. (The algorithm of Premoli--Rastello \cite{PR01,MRPKV02} is not globally convergent to a local solution, so that for particular initial approximations this method might not converge to a local solution. In such cases the algorithm diverges or oscillates.)

The GTLS-type problems (EWGTLS, GTLS, EWGTLS2, and GTLS2) are solved in the package via a transformation technique. The data matrix is appropriately scaled and the corresponding TLS problem is solved for the scaled data. Then the solution of the original problem is recovered from the solution of the transformed TLS problem via the inverse transformation. 

The general WTLS problem is solved via local optimization methods. The following algorithms are used/implemented in the package:
\begin{enumerate}
\item classical local optimization methods (from the Optimization Toolbox of \matlab),
\item an alternating least squares algorithm,
\item the algorithm of Premoli--Rastello.
\end{enumerate}

\subsection*{Implementation}

The implementation is in \matlab\ code. For the problems with analytic solution, the \matlab\ code is expected to compute a solution nearly as fast as an alternative code in C or FORTRAN. The general WTLS algorithms, however, are expected to benefit in terms of execution time if implemented in C or FORTRAN.

A complete list of the \matlab\ code is given in Appendix~\ref{app}. It could be consulted for the implementation details.

\section{Overview of commands}\la{s2}

The package has three main groups of functions: transformations, misfit computations, and approximations. 

The transformation functions convert a given representation of a model to an equivalent one. The considered representations are image, kernel, and input/output, so that there are in total 6 transformation functions among them, see Figure~\ref{f1}. In addition a kernel or an image representation might not be minimal, so that functions that convert a given kernel or image representation to a minimal one are added. The transformation functions are summarized in Table~\ref{t3}.

\begin{figure}[!ht]
$$
\xymatrix
@C=1.75cm
@R=2cm
@M=2mm
{ 
\B=\ker(R) 
\ar@{<->}[rr]^{RP=0} 
\ar@<1mm>[rd]^{X^{\top}=-R_{\tout}^{-1}R_{\tin}} 
&& 
\B=\colspan(P)
\ar@<-1mm>[ld]_{X^{\top}=P_{\tout}P_{\tin}^{-1}} 
\\ &
\B=\B_\io(X)
\ar@<1mm>[ul]^{R = [ X^{\top} \  -I ] } 
\ar@<-1mm>[ur]_{P^{\top} = [ I \ \ X ] } 
}
$$
\caption{Transformations among kernel, image, and input/output representation of a model $\B\in\calL_{\ttm,0}^\ttd$.} \la{f1}
\end{figure}

\begin{table}[htb!]
\centering
\caption{Transformation functions}\la{t3}
\vskip.15cm
\begin{tabular}{|l|cl|}
\hline
Functions & \multicolumn{2}{|c|}{Description}\\
\hline
{\tt x2r}  & $X\mapsto R$ & from input/output to kernel representation\\
{\tt x2p}  & $X\mapsto P$ & from input/output to image representation\\
{\tt r2p}  & $R\mapsto P$ & from kernel to image representation\\
{\tt p2r}  & $P\mapsto R$ & from image to kernel representation\\
{\tt r2x}  & $R\mapsto X$ & from kernel to input/output representation\\
{\tt p2x}  & $P\mapsto X$ & from image to input/output representation\\
{\tt minr} & $R\mapsto R_{\min}$ & minimal kernel representation\\
{\tt minp} & $P\mapsto P_{\min}$ & minimal image representation\\
\hline
\end{tabular}
\end{table}

The misfit computation functions are used for validation: they allow the user to verify how well a given model fits given data in terms of a certain misfit function. Since the model can be specified by one of the three alternative representations---kernel, image, or input/output---all misfit functions have three versions. The following naming convention is adopted: misfit computation functions begin with {\tt m} (for misfit), followed by the name of the approximation problem (which identifies the type of misfit to be computed), followed by a letter, indicating the model representation: {\tt r} for kernel, {\tt p} for image, and {\tt x} for input/output. Instead of a model~$\B$ an approximating matrix~$\hat D\in\R^{\ttd\times N}$ can be used for the misfit computation. In this latter case the last letter of the function name is {\tt dh}.

The considered misfit functions are TLS, GTLS, GTLS2, WTLS, and FWTLS. The element-wise versions of the GTLS, GTLS2, and WTLS misfits are specified by the size of the given weight matrices: if vectors are given in {\tt mgtls\{r,p,x,dh\}} and {\tt mgtls2\{r,p,x,dh\}} instead of square weight matrices, then the EWGTLS and EWGTLS2 misfits are computed instead of the GTLS and GTLS2 ones. Similarly, if an $\ttd\times N$ matrix is given instead of an $\ttd\times\ttd\times N$ tensor in {\tt mwtls\{r,p,x,dh\}}, then the EWTLS misfit is computed instead of the WTLS one. The general FWTLS misfit is computed by the functions {\tt mwtls\{r,p,x,dh\}} if the weight matrix is of size $\ttd N\times\ttd N$. The misfit computation functions are summarized in Table~\ref{t4}.

The approximation functions compute a WTLS approximation of the data. The special WTLS problems are called by special functions that are more efficient, see Table~\ref{t5}. As in the misfit computation, the element-wise versions of the functions are recognized by the dimension of the weight matrices. The function {\tt wtls} uses the quasi-Newton optimization algorithm that seems to outperform the alternatives described in Section~\ref{s1}. The alternative methods can be called by the corresponding functions, see Table~\ref{t6}.

\begin{table}[htb!] 
\begin{minipage}{.65\textwidth}
\centering
\caption{Misfit computation functions}\la{t4}
\vskip.15cm
\begin{tabular}{|llll|l|}
\hline
\multicolumn{4}{|c|}{Function} & \multicolumn{1}{|c|}{Description}\\
\hline
{\tt mtlsr}   & {\tt mtlsp}   & {\tt mtlsx}   & {\tt mtlsdh}      & TLS misfit  \\
{\tt mgtlsr}  & {\tt mgtlsp}  & {\tt mgtlsx}  & {\tt mgtlsdh}     & GTLS misfit \\
{\tt mgtls2r} & {\tt mgtls2p} & {\tt mgtls2x} & {\tt mgtls2dh}    & GTLS2 misfit\\
{\tt mwtlsr}  & {\tt mwtlsp}  & {\tt mwtlsx}  & {\tt mwtlsdh}	  & WTLS misfit \\
\hline
\end{tabular}
\end{minipage}
\begin{minipage}{.35\textwidth}
\centering
\caption{Approximation functions}\la{t5}
\vskip.15cm
\begin{tabular}{|l|l|}
\hline
Function & \multicolumn{1}{|c|}{Description}\\
\hline
{\tt tls}         & TLS approximation\\
{\tt gtls}	  & GTLS approximation\\
{\tt gtls2}	  & GTLS2 approximation\\
{\tt wtls}	  & WTLS approximation\\
\hline
\end{tabular}
\end{minipage}
\end{table}

\begin{table}[htb!]
\centering
\caption{Auxiliary functions}\la{t6}
\vskip.15cm
\begin{tabular}{|l|l|}
\hline
Function & \multicolumn{1}{|c|}{Description}\\
\hline
{\tt wtlsini}	  & initial approximation for the WTLS approximation functions\\
{\tt wtlsap}	  & WTLS approximation by alternating projections\\
{\tt wtlsopt}     & WTLS approximation by classical optimization methods\\
{\tt qncostderiv} & cost function and gradient for the quasi Newton methods\\
{\tt lmcostderiv} & cost function and Jacobian for the Levenberg--Marquardt method\\
{\tt wtlspr}      & WTLS approximation by the algorithm of~\cite{MRPKV02}\\
\hline
\end{tabular}
\end{table}

%\section{Examples}\la{s3}

\section*{Acknowledgments}

{\small Dr. Sabine Van Huffel is a full professor at the Katholieke Universiteit Leuven, Belgium. Research supported by
Research Council KUL: GOA-Mefisto 666, IDO /99/003 and /02/009 (Predictive computer models for medical classification problems using patient data and expert knowledge), several PhD/postdoc \& fellow grants;  Flemish Government: o FWO: PhD/postdoc grants, projects, G.0078.01 (structured matrices), G.0407.02 (support vector machines), G.0269.02 (magnetic resonance spectroscopic imaging), G.0270.02 (nonlinear Lp approximation), research communities (ICCoS, ANMMM); o IWT: PhD Grants;  Belgian Federal Science Policy Office IUAP P5/22 (`Dynamical Systems and Control: Computation, Identification and Modelling');  EU: PDT-COIL, BIOPATTERN, ETUMOUR.
}

%\bibliographystyle{alpha}
%\bibliography{bib,mypapers}

\twocolumn
\appendix
\section{Source code}\la{app}
\subsection*{Transformations}
{\scriptsize
\funinput{x2r.m}
\funinput{x2p.m}
\funinput{r2p.m}
\funinput{p2r.m}
\funinput{r2x.m}
\funinput{p2x.m}
\funinput{minr.m}
\funinput{minp.m}
}
\subsection*{TLS and GTLS misfit computation}
{\scriptsize
\funinput{mtlsr.m}
\funinput{mtlsp.m}
\funinput{mtlsx.m}
\funinput{mtlsdh.m}
\funinput{mgtlsr.m}
\funinput{mgtlsp.m}
\funinput{mgtlsx.m}
\funinput{mgtlsdh.m}
\funinput{mgtls2r.m}
\funinput{mgtls2p.m}
\funinput{mgtls2x.m}
\funinput{mgtls2dh.m}
}
\subsection*{TLS and GTLS approximation}
{\scriptsize
\funinput{tls.m}
\funinput{gtls.m}
\funinput{gtls2.m}
}
\subsection*{WTLS misfit computation}
{\scriptsize
\funinput{mwtlsr.m}
\funinput{mwtlsp.m}
\funinput{mwtlsx.m}
\funinput{mwtlsdh.m}
}
\subsection*{WTLS approximation}
{\scriptsize
\funinput{wtlsini.m}
\funinput{wtlsap.m}
\funinput{wtlsopt.m}
\funinput{qncostderiv.m}
\funinput{lmcostderiv.m}
\funinput{wtlspr.m}
}

\end{document}

